# Core Principles
The following core principles were given to me by a mentor of mine and help guide my thinking about building software in the large and the small.

### 1. Solve the real problem.
### 2. Solve the whole problem.
### 3. The implementation is more flexible than the interface.
### 4. Never let perfect stand in the way of very good.

# Specific Principles
These principles are "rules of thumb" that have proven themselves valuable over time through experience and thus been promoted to the level of a principle.

### 1. Simplicity begets quality.
### 2. Grant the fewest rights necessary to perform an action.
### 3. When choosing a tool for the job, pick the one that gives you no more power than you need, unless that power is free.
### 4. Make real-world error handling automatic whenever possible.
### 5. Lifetime matters.
### 6. Program using local information; design using global information.
### 7. Never treat network resources as if they were local (the NFS lesson).
### 8. Exceptions solbe some problems, but not all.
### 9. Reap the benefits of having invested in solving a hard problem.
### 10. Concurrency is hard.
### 11. High-availability is best implemented with designed-in redundancy, robustness, and scalability.
### 12. Don't trade making the easy easier for making the hard harder.
### 13. Assume the implementation of other components is different from yours.
### 14. Automate what proves to be frequent.
### 15. Be prepared to question your original assumptions.
